#!/usr/bin/env node --max_old_space_size=4096

'use strict';

var fs = require('graceful-fs');
var cover = require('tile-cover');
var byline = require('byline');
var through2 = require('through2');
var stitchWays = require('../lib/stitch-ways');
var unidirectionalWays = require('../lib/unidirectional-ways');
var argv = require('minimist')(process.argv.slice(2));

var waysFile = argv.waysFile;

function loadWays(wayPath, done) {
  var ways = [];
  fs.createReadStream(wayPath)
  .on('end', function () {
    done(null, ways);
  })
  .on('error', function (err) {
    done(err);
  })
  .pipe(byline.createStream())
  .pipe(through2(function (chunk, enc, next) {
    var way = JSON.parse(chunk);

    var zoomLevel = 14;

    var coverQuadkeys = cover.indexes({type: 'LineString', coordinates: way.geometry.coordinates}, {
      'min_zoom': zoomLevel,
      'max_zoom': zoomLevel
    });

    if (coverQuadkeys.length > 1) {
      ways.push(way);
    } else {
      var duplicatedWays = unidirectionalWays([way]);
      for (var i = 0; i < duplicatedWays.length; i++) {
        // putting refs as string for tippecanoe
        duplicatedWays[i].properties.refs = String(duplicatedWays[i].properties.refs);
        process.stdout.write(JSON.stringify(duplicatedWays[i]) + '\n');
      }
    }
    next();
  }));
}

loadWays(waysFile, function (err, ways) {
  if (err) throw err;

  ways = stitchWays(ways);
  for (var i = 0; i < ways.length; i++) {
    var way = ways[i];
    // putting refs as string for tippecanoe
    way.properties.refs = String(way.properties.refs);
    process.stdout.write(JSON.stringify(way) + '\n');
  }
});
